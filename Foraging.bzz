# Swarm Final Project

numRobots = 20
DoneTable = 1
var another_counter = 0

#-------------------LED STUFF--------------------------#


function reset_led() {
	var counter = 0
	while (counter < 11){
		counter = counter + 1
		set_led(0, 0, 0, 0)
	}
}

function set_top_led() {
	reset_led() # Reset the LEDs before changing them
	set_led(12,255,255,255)
}

function set_led_half(start) {
	reset_led() # reset the LEDs before changing them
	LEDVals = {}
	var counter = 0.0
	
	while (counter < 6.0) {
		
		# Set the GREEN LEDs
		if ((counter + start) > 11.0) {
			set_led(math.ceil((counter + start) - 12.0), 0, 255, 0)
			LEDVals[math.ceil((counter + start) - 12.0)] = "g" 
		} else {
			set_led(math.ceil(counter + start), 0, 255, 0)
			LEDVals[math.ceil(counter + start)] = "g"
		}
	
		# Set the RED LEDs
		if ((counter + start + 6.0) > 11.0) {
			set_led(math.ceil((counter + start) - 6.0), 255, 0, 0)
			LEDVals[math.ceil((counter + start) - 6.0)] = "R"
		} else {
			set_led(math.ceil(counter + start + 6.0), 255, 0, 0)
			LEDVals[math.ceil(counter + start + 6.0)] = "R"
		}

		counter = counter + 1.0
	} 
}


# determine_half()
function determine_half(point) {
	# Determine where to place the split in lights
	
	# The point to which the red side should face
	x = point.x
 	y = point.y
	
	# Robot's current coordinates
	a_pose = pose.position
	our_x = a_pose.x
	our_y = a_pose.y
	our_angle = pose.orientation.yaw
	
	# Make angle 0 - 2pi
	if (our_angle < 0.0) {
		our_angle = our_angle + 2 * math.pi
	}
	
	# Calculate the angle from robot to facing point
	angle_to_point = math.atan(-our_y + y, -our_x + x)

	# Make angle 0 - 2pi
	if (angle_to_point < 0) {
		angle_to_point = angle_to_point + 2 * math.pi
	}
	
	# Calculate angle to face relative to robot coordinates
	rel_angle = (angle_to_point - our_angle) 
	return_ang = rel_angle + (math.pi / 2) # offset angle by 90deg
	
	# ensure angle will be between 0 - 2pi
	if (return_ang < 0) {
		return_ang = return_ang + 2 * math.pi
	}
	if (return_ang > 2 * math.pi) {
		return_ang = return_ang - 2 * math.pi
	}
	# Set the leds, convert to a number between 0 - 11
	set_led_half(return_ang * 1.90985)
}


#----------------------WALKING STUFF------------------------#


# Call a specific random walk
function random_walk() {
	obstacle_avoidance()
}


#THRESH:the threshold for the force sum, how accurately do we have to be at the force sum
#xInit: how much we want to prioritize going in the direction it's already going
function SumBlobsMoveInForce(Thresh, xInit){
	if(size(blobs) > 0){
		forceX = xInit
		forceY = 0
		foreach(blobs, function(key, value) {
				dir = 1
 	     if(value['color']['red'] == 255){
					dir = -1
				}
				forceX = forceX + dir*math.cos(value.angle)/value.distance
				forceY = forceY + dir*math.sin(value.angle)/value.distance
	    })

		turnAng = math.atan(forceX,forceY)
		if(turnAng < 0){
			turnAng = 2*math.pi + turnAng
		}
		debug.print(turnAng)
		if(turnAng > 2*math.pi - math.pi/Thresh or turnAng < math.pi/Thresh){
				random_walk()
		}
		else{
			if(turnAng > pi){
				set_wheels(-2.0, 2.0)
			}
			else{
				set_wheels(2.0, -2.0)
			}
		}
	}


}


function obstacle_avoidance() {
	var magnitude = 5.0
	#log("Obstacle avoiding")
		var problem = read_proximity().problem_a
		#log(problem)
		# Decide whether to turn left or right
		x = magnitude * math.cos(math.pi + problem)
		y = magnitude * math.sin(math.pi + problem)
	
		# If angle is behind robot, nothing is detected
		if (problem == -math.pi) {
			# Nothing is detected
			set_wheels(magnitude, magnitude)
		}	 else {
		
			# Something is detected
			#	Isolate near 0 cases to avoid errors
			if (x < 0.000001 and x > -0.000001){
				x = 0
			}

			if (y < 0.000001 and y > -0.000001){
				y = 0
			}

			# log("Wheel Speed X: ", x)
			# log("Wheel Speed Y: ", y)
			# Go to point that is opposite side from obstacle
			gotoc(x*10 / 2, y*10 / 2)
			#gotop(1,  
		}
}


#----------------------_SENSOR READING-------------------_#


function read_proximity() {

	# Iterate through all the proximity sensors, find detections
	var counter = 0
	
	var max_reading = 0.0
	var problem_angle = -math.pi

	while (counter < 23 and (loop_counter < 3 or loop_counter > 21)) {
		var frontValue = proximity[counter].value
		var frontAngle = proximity[counter].angle
		if (frontValue > max_reading) {
			max_reading = frontValue
			problem_angle = frontAngle # log the problem angle
			#log("Obstacle detected in front of Sensor: ", counter)
			#log("Reading: ", max_reading, " Angle: ", frontAngle)
		}
		counter = counter + 1
	}
	
	# Setup the return table
	t = { .max_r = max_reading, .problem_a = problem_angle}
	return t
}



#-----------------DEFAULT FUNCTIONS-------------------#


# Initialization
function init(){
	camera_enable()
	#v = stigmergy.create(DoneTable) 
	#v.put(DoneTable, {})
}

#state maching
function step() {
	log(id,"-",math.sqrt(pose.position.x*pose.position.x + pose.position.y*pose.position.y))
	# the point where all the robots face their red side
	point2 = {.x = 0.0, .y = 0.0}

	determine_half(point2)
	#debug.print(Count, ":", State)
	#another_counter = another_counter + 1
	#set_led_half(another_counter % 12)
	SumBlobsMoveInForce(15, 0)

	#if(size(v.get(DonTable))>= numRobots){
	#	Debug.print("DONE")
	#}
#__________________________________#
}

function reset(){
}
# Execute at exit
function destroy() {
}
