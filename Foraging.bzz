Count = 0#Steps away from hive
#the state to perform. H is home, S is Search, R is Return (home), T is Rotate to theta degrees
State = 'H' 
#How long a bot has to look for food before going home
CountMax = 200
#Do we count forwards, indicating searching, backwords, indicating returning home, or 0, no count increase
CountState = 0
dToFood = 0 #Count to food, will need to do Countmax minus this to get the actual distance, this should be renamed to d to nest
angToRob=0
path = {}#each count creates an associated move vector

usePath = 0 #use the path when searching?

CanBeacon = 0 #Can recieve a beacon signal, triggerinbg a turn. This name is misleading, as 0 is true and 1 is false
#THIS CAN BE SWAPPED OUT WITH
#neighbors.listen("key",
#   function(vid, value, rid) {
#      log("Got (", vid, ",", value, ") from robot #", rid)
#   }
#)
v = stigmergy.create(1)

function init(){
	Count = 0  
	State = 'H'
	math.rng.setseed(id)
	foodandrange={}
	foodandrange["food"] = 0
	foodandrange["range"] = 0
	v.put(id, foodandrange)
}
# at_hive()
# return True (1) if at the hive
# return False (0) if not at the hive
#function at_hive() {
#	var hive_threshold = 0.550 # Threshold compared to light reading to determine if at hive
#	var loop_counter = 0
#	var max_reading = 0;
#	var max_angle = 0;

#	while (loop_counter < 8) {
		
#		light_obj = light[loop_counter]
#		light_reading = light_obj['value']
#		light_angle = light_obj['angle']
		
#		if (max_reading < light_reading) {
#			max_reading = light_reading
#			max_angle = light_angle
#		}
#		loop_counter = loop_counter + 1
#	}
#	log(id, " reading: ", max_reading, " angle: ", max_angle)
		
#	if (max_reading > hive_threshold) {
#		return 1
#	}	else {
#		return 0
#	}	
#}
#IF HOME, turn off food beacon
#if food was not found, reset the path, and allow for a beacon trigger
function stateHome(){
	foodandrange = v.get(id)
	foodandrange["food"] = 0
	foodandrange["range"] = Count
	v.put(id,foodandrange)
	if(math.rng.uniform(10001)>9950 and usePath == 0){
		set_wheels(0.0,0.0)
		State = 'S'
		CountState = 1
		if(usePath == 0){
			path = {}
			CanBeacon = 0
		}
	}
}
#record the current path into count to return home
function record(lf, rw, bcn){
	if(CountState == 1 and usePath == 0){
		temp = {}
		temp["lf"] = lf
		temp["rw"] = rw
		temp["bcn"] = bcn
		path[Count] = temp
	
		}

}

#move the specified way in the specified direction
#update the range from the nest
function setWheelsCount(){

		foodandrange = v.get(id)
		foodandrange["range"] = Count
		v.put(id,foodandrange)
	set_wheels(CountState*path[Count]["lf"],CountState*path[Count]["rw"])
}

#look for the food
function stateSearch(){
	if(Count < CountMax){
		record(10.0,10.0, 0)
		setWheelsCount()
	}
	else{
		CountState = -1
		State = 'R'
	}
}

#go back on the path from which you came
function stateReturn(){
	if(Count > 0){
		setWheelsCount()
	}
	else{
		State = 'H'
		CountState = 0
		foodandrange = v.get(id)
		foodandrange["food"] = 0
		foodandrange["range"] = Count
		v.put(id,foodandrange)
		goto(0,0)
	}
}

#turn to some function of where the robot who found food is, then GO
function rotateTheta(){
	if(math.abs(angToRob)<3.14159/5){
		record(0.0,0.0,0)
		setWheelsCount()
		State = 'S'
	}
	else{
#Moves 2pi/331 a tick
		debug.print("AngToRob", angToRob)
		if(angToRob<0){
			record(1.0, -1.0,0)
			setWheelsCount()
			angToRob = angToRob + 2*3.14159/331
			#debug.print(pose.orientation.azimuth)
		}
		else{
			record(-1.0, 1.0,0)
			setWheelsCount()
			angToRob = angToRob - 2*3.14159/331
		}
	}
}


#if the neighbor has beaconed and found food, than accept the beacon and initiate a turn
function checkBeacon(){
	neighbors.foreach(
  function(rid, data) {
		debug.print("IS: ", v.get(rid)["range"])
  	if(v.get(rid)["food"] == 1  and v.get(rid)["range"] > 10){
			#debug.print("IS: ", rid, data, data.azimuth)
			State = 'T'
			dToFood = v.get(rid)["range"]
			angToRob = data.azimuth
			CanBeacon = 1
			CountMax = 300
		}

 })
}


#see if we're close to the light. If we are, start beaconing, and return home
function checkFood(){
#NEEDSS TO BE VECTOR SUMMMM!!!!
max_reading = 0 
loop_counter = 0
	while (loop_counter < 8) {
		
		light_obj = light[loop_counter]
		light_reading = light_obj['value']
		light_angle = light_obj['angle']
		
		if (max_reading < light_reading) {
			max_reading = light_reading
			max_angle = light_angle
		}
		loop_counter = loop_counter + 1
	}
	if(id == 70){
		max_reading = max_reading + 0.08	
	}
	if(max_reading >=0.85){
		debug.print("Food!")
		usePath = 1
		CanBeacon = 1
		foodandrange = v.get(id)
		foodandrange["food"] = 1
		foodandrange["range"] = Count
		v.put(id,foodandrange)
		State = 'R'
		CountState = -1
	}
	else{
		debug.print(Count, ":", max_reading)
	}
}

#state maching
function step() {
	#debug.print(Count, ":", State)

	if(State == 'H'){
		stateHome()
	} else if(State == 'S'){
		stateSearch()
		checkFood()
		if(CanBeacon == 0)
			checkBeacon()
		
	} else if(State == 'R'){
		if(usePath==1){
			foodandrange = v.get(id)
			foodandrange["range"] = Count
			v.put(id,foodandrange)
		}
		stateReturn()
	} else if(State == "T"){
		rotateTheta()
	}
	


#__________________________________#
#states for counting, 0 is no count, 1 is positive count, -1 is negitive count
	if(CountState == 1){		foodandrange["food"] = 0
		Count = Count + 1
	}
	if(CountState == -1){
		Count = Count - 1
	}
#__________________________________#
}
 
function reset(){
}
# Execute at exit
function destroy() {
}
